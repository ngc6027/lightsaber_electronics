#include <xc.h>
#include <p32xxxx.h>
#include <plib.h>
#include <peripheral/spi.h>

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

#include "pmodsf.h"

#define SPI_PRI         2
#define SPI_SUBPRI      0
#define INS_PER_10MS    400000
#define M25P16_CSn      LATFbits.LATF12

//typedef enum{
//    
//}spi_state_t;

void __ISR(_SPI_4_VECTOR, IPL2AUTO) spi_handler(void)
{
    static int x = 0, y = 0, z = 0;
    static uint8_t rx_data[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    // check if the interrupt was generated by transmit; this means that the
    // SPI module transmit buffer is empty and can write another byte.
    if (IFS1bits.SPI4TXIF){
        if (x == 0){
            M25P16_CSn = 0;
            SPI4BUF = M25P16_WREN;
            x++;
        } else if (x == 1){
            M25P16_CSn = 1;
            x++;
        } else if (x == 2){
            M25P16_CSn = 0;
            SPI4BUF = M25P16_WRSR;
            x++;
        } else if (x == 3){
            SPI4BUF = 0x08; // write dummy byte so SCK continues for reading
            x++;
        } else if (x == 4){
            M25P16_CSn = 1;
            x++;
        } else if (x == 5){
            M25P16_CSn = 0;
            SPI4BUF = M25P16_RDSR;
            x++;
        } else if (x == 6){
            SPI4BUF = 0x00;
            x++;
        } else if (x == 7){
            M25P16_CSn = 1;
            x = 0;
        } else {
            x = 0;
        }
        
        IFS1bits.SPI4TXIF = 0;
    }
    
    // check if interrupt was generated by receive; this means that receive data
    // is available in SPIxBUF
    if (IFS1bits.SPI4RXIF){
        if (y < 10){
            rx_data[y++] = SPI4BUF;
        } else {
            y = 0;
            rx_data[y++] = SPI4BUF;
        }
        
        IFS1bits.SPI4RXIF = 0;
    }
    
    // check if interrupt was generated by error; this means that the receive
    // buffer has overflowed, that new data has been received but the previous
    // data was not read.
    if (IFS1bits.SPI4EIF){
        SPI4STATbits.SPIROV = 0;
        z++;
        
        IFS1bits.SPI4EIF = 0;
    }
    
    return;
}

void initialize_spi()
{
    SPI4CON = 0; // turn off SPI module 4 and set all settings to 0
    uint8_t junk = SPI4BUF;
    
    // clear receive, transmit, and error interrupt status bits for SPI4 module
    IFS1bits.SPI4TXIF = 0;
    IFS1bits.SPI4RXIF = 0;
    IFS1bits.SPI4EIF = 0;
    
    // clear previous interrupt priority and subpriority for SPI4 module
    IPC8bits.SPI4IP = 0x0;
    IPC8bits.SPI4IS = 0x0;
    
    // set interrupt priority and subpriority for SPI4 module
    IPC8bits.SPI4IP = SPI_PRI;
    IPC8bits.SPI4IS = SPI_SUBPRI;
    
    // turn on transmit, receive, and error interrupts for SPI4 module
    IEC1bits.SPI4TXIE = 1;
    IEC1bits.SPI4RXIE = 1;
    IEC1bits.SPI4EIE = 1;
    
    // set up the buffer for SPI4 module
    //SPI4BRG = 0x00; // set BRG for SPI4
    SPI4BRG = 0x13;
    SPI4STATbits.SPIROV = 0; // clear Receive Overflow Flag for SPI4 module
    
    // set up SPI4 module control bits
    SPI4CONbits.SMP = 1;    // input data sampled at end of data output time
    SPI4CONbits.MSTEN = 1;  // put SPI4 module into master mode
    //SPI4CON = SPI4CON & 0x00004000; // Freeze during DEBUG
    SPI4CONbits.ON = 1;     // turn on SPI4 module
    
    //set chip select pin high
    TRISFbits.TRISF12 = 0;
    M25P16_CSn = 1; 
    
    return;
}

void initialize_M25P16()
{
    // wait 10 ms from when power is applied to the circuit
    // no other initialization is needed
    int i = 0;
    for(i = 0; i < INS_PER_10MS; i++){
        ;
    }
}